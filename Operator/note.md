## 位运算
整数在计算机中用二进制的位来表示，C语言提供一些运算符可以直接操作整数中的位，称为位运算，这些运算符的操作数
都必须时整型的。

### & | ^ ~

### 移位运算 Bitwise Shift
在一定范围内，由于计算机做移位运算比做惩罚快得多，编译器可以利用这一点进行优化，比如看到源代码中有i * 8， 可以编译成移位指令而不是
乘法指令。

当操作数是有符号数时，右移运算的规则比较复杂：
- 如果是正数，那么高位移入0
- 如果是负数，那么高位一如1还是0不一定，这是Implementation-defined. 对于x86平台的gcc编译器，最高位移入1，也就是仍保持负数的符号位，
这种处理方式对负数仍然保持了“右移一位相当于除以2”的性质。

综上所述，建议只对无符号数做位运算，以减少出错的可能性。


### 掩码

### XOR
1. 一个数和自己做异或的结果是0。 如果需要一个常熟0，x86平台的编译器可能会生成这样的指令: xorl %eax, %eax 。不管eax寄存器里的值原来是多少，做异或
运算都能得到0.这条指令比同样效果的movl $0, %eax 指令快，直接对寄存器做位运算比生成一个立即数在传送到寄存器要快一些。 

2. 和0做异或保持原值不变，和1做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的反转：
```
unsigned int a, b, maks = 1U << 6;
b = a ^ mask; /* flip the 6th bit */
```

3. 如果a1^a2^a3^...^an的结果是1，则表示a1,a2,a3,...,an之中1的个数位奇数个，否则为偶数个。这条性质可用于奇偶校验(Parity Check), 比如再串口通信过程中，每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位粗略地判断接收到地数据是否有误。

4. x^x^y == y,  因为x^x == 0, 0^y == y。
利用位运算可以这样做交换
```
a = a ^ b;
b = b ^ a;
a = a ^ b;
```
a = a0 ^ b0;
b = b0^a0^b0;
a = a0 ^ b0 ^ a0;

Ex 1. 网上查找RAID (Redundant Array of Independent Disks) ，利用了本节地3,4性质。

Ex 2. 另外一个方法将变量跟自己交换？ 本节方法，变量不能跟自己交换，你的方法有没有局限性？

## 其他运算符
### 复合赋值运算符
Compund Assignment Operator ,一边做运算，一边赋值。
a += 1 相当于 a = a + 1.
但前者对表达式a只求值一次，而后者求值两次，如果a是一个复杂的表达式，求值一次和求值两次的效率是不同的。
如:
a[i+j] += 1 和 a[i+j] = a[i+j] + 1.

那么，这仅仅是效率上的差别吗？
对于没有Side Effect的表达式，求值一次和两次结果一致。
对于有Side Effect的表达式则不一定，例如:
a[foo()] += 1 和 a[foo()] = a[foo()] + 1
如果foo()函数中会打印一条消息，那么前者只打印一次，后者打印两次。

### 条件运算符
Conditional Operator  是C语言中唯一的三目运算符(Temary Operator). 
表达式1 ? 表达式2 ： 表达式3
表达式1相当于if语句的控制表达式，因此他的值必须是标量类型。
而表达式2和表达式3相当于同一个函数在不同情况下的返回值，因此他们的类型要求基本一直，也要做Usual Arithemetic Conversion。
```
int max(int a, int b)
{
	return (a>b) ? a : b;
}
```

### 逗号运算符
表达式1, 表达式2
两个表达式不要求类型一致，左边的表达式1先求值，秋晚了直接把值给丢掉，再求右边表达式2的值作为整个表达式的值。
```
f(a,(t=3,t+2),c)
```
传给函数f的参数有三个，其中第二个参数的值是表达式t+2的值。

### sizeof 运算符与 typeof类型声明
sezeof是一个很特殊的运算符，它有两种形式:
"sizeof 表达式" 和 "sizeof(类型名)".
这个运算符很特殊，"sezeof 表达式" 中的子表达式并不求值，而是根据类型转换规则求得子表达式的类型，然后把这种类型所占的字节数作为整个表达式的值。
写成 sizeof(表达式) 的形式也可以，这里的括号和 return(1)一样，不起任何作用。

sizeof运算符的结果是size_t类型的，这个类型定义在stddef.h头文件中，不过你的代码中只要不出现size_t这个类型名就不用包含这个头文件。
C标准规定size_t是一种无符号整型，编译器可以用typedef做一个类型声明:
```
typedef unsigned long size_t;
```

typedef 这个关键字用于给某种类型起个新名字，比如上面的typdef声明就可以这么看。
去掉了typdef就成了一个变量声明unsigned long size_t; size_t是一个变量名，类型是unsigned long。 
那么加上typedef 之后，size_t就是一个类型名，就代表unsigned long类型。
```
typdef char array_t[10];
array_t a;
```
这相当于声明char a[10] . 类型名业巡巡标识符的命名规则，而且通常加个\_t 后缀表示type.
C标准库的头文件stdint.h中定义了很多这样的类型名。 


