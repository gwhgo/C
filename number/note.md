## Gate and Wire
XOR OR AND 
NAND NOR Inerter 
Cin Cout

 - 1-bit Full Adder
 - Ripple Carray Adder


## Add and Substract

### Sign and Magnitude 
8bit -> -2^7 - 1 ~ 2^7 - 1 <=> -127 ~ 127
加法运算：
- 如果两数字符号位相同， 低七位相加，符号位不变。如果低七位再相加时产生最高位进位，说明结果大于127,超过表示范围，Overflow。通常把计算机中的一个标志位标为1表示当前运算产生了溢出。
- 如果两位符号不同，大数减小数， 符号位与大数相同。
减法运算： a - b <=> a + (-b)
但是如果a 和 -b符号位不同，仍要进行减法运算。
> 加法要进位，减法要借位，计算过程不同，所以除了加法器电路，还需要减法器电路。

如果采用Sign and Magnitude 表示法，计算机做加减法运算需要处理很多逻辑： 比较符号位，比较绝对值，加法改减法，减法改加法，小数减大数改成大数减小数, 效率非常低。
同时，0的表示不唯一，10000000 和 00000000都是0,进一步增加了逻辑的复杂性。

### 1's complement
Ex 9's complement
167 - 52 = 167 + (-52) = 167 + (999 - 52) - 1000 + 1 = 167 + 947 - 1000 + 1 = 1114 - 1000 +  = 114 + 1 = 115
> -499的补码为 500， -1 的补码为998, 0的补码为999.
> 0的补码为0，1的补码为1，498的补码为498.
负数用9的补码表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去。
-52 + -52 = （999-52） + （999-52） - 1000 - 1000 + 1 +1
= 947 + 947 - 1000 - 1000 + 1 + 1
= 1894 - 1000 -1000  + 1 + 1
= -106 + 2 = -104

Ex 1's complement
00001000 - 00000100 -> 00001000 + (-00000100) -> 00001000 + 11111011 -> 00000011
高位进的1加到低位上去: 00000100
-00001000 - 00000100 -> 11110111 + 11111011 ->  11110010 - 100000000  + 1 + 1
两个负数的情况是无法解决的，只能回到过去的逻辑：
1. 判断是否为同符号， Yes -> 2, NO -> 3
2. 相加, 使用相同的符号
3. 对负数，进行1’s complement 运算


1's complement  的优势 ： 不需要减法电路，只需要一套减法电路，和一套把每个位取反的电路
负数 -127 - 0 整数 0 - 127
10000000 00000000都在表示0.

#### 2's Complement
正数不变，负数取反+1,计算后忽略最高位的进位

00001000 - 00000100 -> 00001000 + 11111100 -> 00000100

-00001000 - 00000100 -> 11111000 + 11111100 ->  11110100 ( - 00001100)

-1 -> 11111111

define
-128 -> 1000000

如何判定溢出？
在相加过程中有最高位产生的进位和此高位产生的进位，如果相同则没有溢出，如果不同则表示有溢出。

### 有符号数和无符号数
上面讲了三个表示法，每种表示法对应一种计算规则，这成为有符号数(Signed Number). 如果8个bit全部表示整数啧取值范围是0~255.这称为无符号数(Unsigned Number)。 其实计算机做加法时并不区分操作数时有符号数还是无符号数，计算过程都一样。
	10000010         130
+	11111000      +  248
-------------- = ------------
   101111010	     122 + 256
计算机的加法器在做完计算之后，根据最高位产生的进位设置进位标志，同时根据最高位和次高位产生的进位异或设置溢出标志。
至于这个加法到底是有符号数加法 还是 无符号数加法 则取决于程序怎么理解，如果程序把它理解成有符号数加法，下一步就要检查溢出标志；如果程序把它理解成无符号数加法，下一步就要检查进位标志。
如果计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有为都是0，则设置0标志。如果计算机过的最高位是1啧设置为负数标志；如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正还是负。

## 浮点数
浮点数在计算中的表示是基于科学计数法(Scientific Notation)的，32767 -> 3.2767 x 10^4 , 3.2767 称为尾数(Mantissa,或者叫Significand), 4称为指数(Exponent)。浮点数在计算机中的表示与此类似，只不过基数(Radix) 是 2 而不是 1。
下面我们用一个简单的模型来表示解释浮点数的基本概念。 我们的模型由三部分组成： 符号位、指数部分(表示2的多少次方)和尾数部分（小数点前面是0，尾数部分只表示小数点后的数字）：

---------------------------------------------------------------
  1bit  |  		5bit 	     |            8bit 				  |
---------------------------------------------------------------
  sign         exponent 				  significand
   bit

Ex: 表示17这个数
$$
17 = 17.0 x 10^0 = 0.17 x 10^2 
   = (10001)_2 * 2^0 = (0.10001)_2 x 2^5
$$

---------------------------------------------------------------
  0   |  		00101 	     |            10001000 				  |
---------------------------------------------------------------

但是如果要表示0.25就遇到困难了，$ 0.25 = 1 x 2^{-2} = (0.1)_2 x 2^{-1}$_
我们的模型中没有规定如何表示负数，我们可以在指数部分规定一个符号位，然后更广泛采用的办法是使用偏移的指数(Biased Exponent). 规定一个偏移值，比如16，比16小的就表示负数，要表示0.25, 指数部分应该填16 - 1 。
还有一个问题需要解决，每个浮点数的表示都不唯一，例如 17 = (0.10001)_2 x 2^5 = (0.010001)_2 x 2^6 . 这样给计算机处理增加了复杂性。为了解决这个问题，我们规定尾数部分的最高位必须是1， 也就是说尾数必须以0.1开头，这个1就不必保存了，正称为 正规化（Normalize)。 由于尾数部分的最高位必须是1，这个1就不必保存了，这样可以节省出来一位用来提高精度。 我们说最高位的1是隐含的(Implied)。 这样17就只有一种表示方法了，指数部分应该是16 + 5 = 21 = （10101)_2 ,_ 尾数部分去掉最高位的1是0001：
---------------------------------------------------------------
  0   |  		10101 	     |            00010000 				  |
---------------------------------------------------------------
两个浮点数相加，首先把小数点对齐然后相加：
---------------------------------------------------------------
  0   |  		10010 	     |            10010000 				| + 
--------------------------------------------------------------- 

---------------------------------------------------------------
  0   |  		10000 	     |            00110110 				|  = 
--------------------------------------------------------------- 
---------------------------------------------------------------
  0   |  		10010 	     |            11011101 				|  
--------------------------------------------------------------- 



	11.00010000
+	 0.100110110
--------------------
	11.101110110


由于浮点数表示的精度有限，计算结果末尾的10两位被舍去了。 做浮点运算时要注意精度损失 (Significance Loss) 问题，有时计算顺序不同也会导致不同的结果。
比如 11.00100000 + 0.00000001 + 0.00000001 = 11.00100000 + 0.00000001 + 0.00000001  = 11.00100000, 后面两个很小的数全部都被舍去了。 但是如果调整一下计算顺序，就能够影响计算结果了。 
0.00000001 + 0.00000001 + 11.00100000 = 0.00000010 + 11.0010000  = 11.0010001 

