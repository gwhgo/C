## struct
main函数反汇编:
```
       s.a = 1;
  40053c:       c6 45 f0 01             movb   $0x1,-0x10(%rbp)
        s.b = 2;
  400540:       66 c7 45 f2 02 00       movw   $0x2,-0xe(%rbp)
        s.c = 3;
  400546:       c7 45 f4 03 00 00 00    movl   $0x3,-0xc(%rbp)
        s.d = 4;
  40054d:       c6 45 f8 04             movb   $0x4,-0x8(%rbp)
```
从访问结构体成员的指令可以看出，结构体的四个成员在栈上的排列如下：
```
高地址
----
d
----
c
---
b
---
a
---
低地址
```
虽然栈是从高地址向低地址增长，但结构体成员也是从低地址向高地址排列的，这一点和数组类似。但有一点和数组不同，结构体的各成员并不是一个紧挨着一个排列的，中间有空隙，称为Padding。不仅如此，结构体的末尾也有三个字节的填充，所以sezeof(s)的值是12。
为什么编译器要这样处理呢？  对齐
不对齐 -> 1. 无法访问 2.效率低
本例中的结构体，编译器会把它的基地址对齐到4字节边界。
填充放入s.b,以对其两个字节.
s.c四个字节，无需padding。
s.d需要padding。以便于这个结构体后的变量地址，比如结构体数组。

而数组必须紧紧挨着，以便用下标访问。

合理设计结构体各个成员的排列顺序可以节省存储空间，比如改为：
struct {
	char a;
	char d;
	short b;
	int c;
}

此外,gcc提供一种语法消除结构体的填充字节:
struct {
	char a;
	short b;
	int c;
	char d;
} __attribute__((packed)) s;
但是这样不能保证对其，在访问b和c时会有效率问题，甚至无法访问，所以除非有特别的理由，不建议使用。

### Bit-field


